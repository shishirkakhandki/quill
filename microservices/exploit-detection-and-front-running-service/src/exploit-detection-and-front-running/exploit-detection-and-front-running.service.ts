import { Injectable, OnModuleInit, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { ethers } from 'ethers';
import axios from 'axios';
import * as abi from '../abis/contract-abi.json';

@Injectable()
export class ExploitDetectionAndFrontRunningService implements OnModuleInit {
  private readonly logger = new Logger(
    ExploitDetectionAndFrontRunningService.name,
  );
  private provider: ethers.providers.JsonRpcProvider;
  private wallet: ethers.Wallet;
  private contractAddress: string;
  private workflowServiceUrl: string;
  private contract: ethers.Contract;

  constructor(private configService: ConfigService) {
    this.logger.log('ExploitDetectionService constructor called');
    this.initializeConfig();
    this.contract = new ethers.Contract(this.contractAddress, abi, this.wallet);
  }

  private initializeConfig() {
    this.logger.log('Initializing configuration');
    const rpcUrl = this.configService.get<string>('RPC_URL');
    const contractAddress = this.configService.get<string>('CONTRACT_ADDRESS');
    const workflowServiceUrl = this.configService.get<string>(
      'WORKFLOW_SERVICE_URL',
    );
    const privateKey = this.configService.get<string>('PRIVATE_KEY');

    if (!rpcUrl || !contractAddress || !workflowServiceUrl || !privateKey) {
      throw new Error('Missing required configuration values');
    }

    this.logger.log(`RPC URL: ${rpcUrl}`);
    this.logger.log(`Contract Address: ${contractAddress}`);
    this.logger.log(`Workflow Service URL: ${workflowServiceUrl}`);

    this.provider = new ethers.providers.JsonRpcProvider(rpcUrl);
    this.wallet = new ethers.Wallet(privateKey, this.provider);
    this.contractAddress = contractAddress;
    this.workflowServiceUrl = workflowServiceUrl;

    this.logger.log('Configuration initialized');
  }

  async onModuleInit() {
    this.logger.log('onModuleInit called');
    await this.testConnection();
    this.monitorMempool();
    this.monitorBlocks();
  }

  private async testConnection() {
    try {
      const blockNumber = await this.provider.getBlockNumber();
      this.logger.log(
        `Connected to network. Current block number: ${blockNumber}`,
      );
    } catch (error) {
      this.logger.error(`Failed to connect to network: ${error.message}`);
    }
  }

  private monitorMempool() {
    this.logger.log('Starting mempool monitoring');
    this.provider.on('pending', (txOrHash) => {
      this.logger.log(
        `Pending transaction detected: ${JSON.stringify(txOrHash)}`,
      );
      this.processPendingTransaction(txOrHash);
    });
  }

  private monitorBlocks() {
    this.logger.log('Starting block monitoring');
    this.provider.on('block', (blockNumber) => {
      this.logger.log(`New block detected: ${blockNumber}`);
      this.processBlock(blockNumber);
    });
  }

  private async processPendingTransaction(
    txOrHash: string | ethers.providers.TransactionResponse,
  ) {
    try {
      let tx: ethers.providers.TransactionResponse;
      if (typeof txOrHash === 'string') {
        this.logger.log(`Processing pending transaction hash: ${txOrHash}`);
        tx = await this.provider.getTransaction(txOrHash);
        if (!tx) {
          this.logger.log(`Transaction ${txOrHash} not found in mempool`);
          return;
        }
      } else {
        tx = txOrHash;
      }

      this.logger.log(`Transaction details: ${JSON.stringify(tx)}`);

      if (tx.to?.toLowerCase() === this.contractAddress.toLowerCase()) {
        this.logger.log(
          `Pending transaction to monitored contract: ${tx.hash}`,
        );
        await this.decodePendingTransaction(tx);
      } else {
        this.logger.log(`Transaction ${tx.hash} is not for monitored contract`);
      }
    } catch (error) {
      this.logger.error(
        `Error processing pending transaction: ${error.message}`,
      );
    }
  }

  private async processBlock(blockNumber: number) {
    this.logger.log(`Processing block: ${blockNumber}`);
    try {
      const block = await this.provider.getBlockWithTransactions(blockNumber);
      for (const tx of block.transactions) {
        if (tx.to?.toLowerCase() === this.contractAddress.toLowerCase()) {
          this.logger.log(
            `Found transaction to monitored contract in block ${blockNumber}: ${tx.hash}`,
          );
          await this.decodePendingTransaction(tx);
        }
      }
    } catch (error) {
      this.logger.error(`Error processing block: ${error.message}`);
    }
  }

  private async decodePendingTransaction(
    tx: ethers.providers.TransactionResponse,
  ) {
    this.logger.log(`Decoding transaction: ${tx.hash}`);
    try {
      const decodedData = this.contract.interface.parseTransaction({
        data: tx.data,
      });
      this.logger.log(`Decoded function name: ${decodedData.name}`);

      if (decodedData.name === 'withdraw') {
        this.logger.log(`Withdraw function called in transaction: ${tx.hash}`);
        const isPaused = await this.contract.paused();
        if (!isPaused) {
          const exploitData = {
            address: tx.from,
            amount: ethers.utils.formatEther(tx.value),
            transactionHash: tx.hash,
            blockNumber: tx.blockNumber?.toString() || 'pending',
            gasUsed: tx.gasLimit.toString(),
            contractAddress: tx.to,
            exploitType: 'withdraw',
            status: tx.blockNumber ? 'confirmed' : 'pending',
          };
          const pauseResult = await this.frontRunTransaction();
          await this.notifyWorkflowService(exploitData, pauseResult);
        } else {
          this.logger.log(
            `Contract is already paused. Transaction ${tx.hash} will not be reported`,
          );
        }
      } else {
        this.logger.log(`Transaction ${tx.hash} is not a withdraw call`);
      }
    } catch (error) {
      this.logger.error(`Error decoding transaction: ${error.message}`);
    }
  }

  private async frontRunTransaction(): Promise<boolean> {
    const maxRetries = 3;
    const retryDelay = 1000; // 1 second
    let currentGasLimit = ethers.BigNumber.from('300000'); // Starting gas limit

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        this.logger.log(`Pause attempt ${attempt} of ${maxRetries}`);

        this.logger.log('Checking if contract is already paused...');
        const isPaused = await this.contract.paused();

        if (isPaused) {
          this.logger.log('Contract is already paused');
          return true;
        }

        this.logger.log('Attempting to pause contract...');

        const gasPrice = await this.getAdjustedGasPrice();

        try {
          const estimatedGas = await this.contract.estimateGas.pause();
          currentGasLimit = estimatedGas.mul(120).div(100);
          this.logger.log(
            `Estimated gas (with buffer): ${currentGasLimit.toString()}`,
          );
        } catch (estimateError) {
          this.logger.warn(`Failed to estimate gas: ${estimateError.message}`);
          currentGasLimit = currentGasLimit.mul(120).div(100);
          this.logger.log(
            `Increased gas limit to: ${currentGasLimit.toString()}`,
          );
        }

        const tx = {
          gasLimit: currentGasLimit,
          gasPrice: gasPrice,
        };

        this.logger.log(
          `Sending transaction with gas limit: ${currentGasLimit.toString()}`,
        );
        const txResponse = await this.contract.pause(tx);
        this.logger.log(`Pause Transaction Hash: ${txResponse.hash}`);

        const receipt = await txResponse.wait();
        this.logger.log(
          `Transaction confirmed in block ${receipt.blockNumber}`,
        );

        if (receipt.status === 1) {
          this.logger.log('Contract paused successfully');
          return true;
        } else {
          this.logger.error('Transaction failed');
          return false;
        }
      } catch (error) {
        this.logger.error(
          `Failed to pause the contract (attempt ${attempt}):`,
          error,
        );
        this.logDetailedError(error);

        if (attempt < maxRetries) {
          this.logger.log(`Retrying in ${retryDelay}ms...`);
          await new Promise((resolve) => setTimeout(resolve, retryDelay));
        } else {
          this.logger.error(
            'Max retries reached. Unable to pause the contract.',
          );
          return false;
        }
      }
    }

    return false;
  }

  private logDetailedError(error: any) {
    if (error.reason) {
      this.logger.error('Error reason:', error.reason);
    }
    if (error.code) {
      this.logger.error('Error code:', error.code);
    }
    if (error.method) {
      this.logger.error('Error method:', error.method);
    }
    if (error.transaction) {
      this.logger.error(
        'Error transaction:',
        JSON.stringify(error.transaction),
      );
    }
    if (error.error && error.error.message) {
      this.logger.error('Detailed error message:', error.error.message);
    }
  }

  private async getAdjustedGasPrice(): Promise<ethers.BigNumber> {
    const gasPrice = await this.provider.getGasPrice();
    this.logger.log(`Current Gas Price: ${gasPrice.toString()}`);
    const adjustedGasPrice = gasPrice.mul(110).div(100); // Increase by 10%
    this.logger.log(`Adjusted Gas Price: ${adjustedGasPrice.toString()}`);
    return adjustedGasPrice;
  }

  private async notifyWorkflowService(data: any, pauseSuccessful: boolean) {
    this.logger.log(
      `Notifying workflow service: ${JSON.stringify({ ...data, contractPaused: pauseSuccessful })}`,
    );
    try {
      await axios.post(`${this.workflowServiceUrl}`, {
        ...data,
        contractPaused: pauseSuccessful,
      });
      this.logger.log('Workflow service notified successfully');
    } catch (error) {
      this.logger.error('Failed to notify workflow service:', error.message);
    }
  }
}
