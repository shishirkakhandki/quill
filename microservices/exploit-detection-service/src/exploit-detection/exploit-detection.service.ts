import { Injectable, OnModuleInit, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { ethers } from 'ethers';
import axios from 'axios';
import * as abi from '../abis/contract-abi.json';

@Injectable()
export class ExploitDetectionService implements OnModuleInit {
  private readonly logger = new Logger(ExploitDetectionService.name);
  private provider: ethers.providers.JsonRpcProvider;
  private contractAddress: string;
  private workflowServiceUrl: string;
  private contract: ethers.Contract;

  constructor(private configService: ConfigService) {
    this.initializeConfig();
    this.contract = new ethers.Contract(
      this.contractAddress,
      abi as any,
      this.provider,
    );
  }

  private initializeConfig() {
    const rpcUrl = this.configService.get<string>('RPC_URL');
    const contractAddress = this.configService.get<string>('CONTRACT_ADDRESS');
    const workflowServiceUrl = this.configService.get<string>(
      'WORKFLOW_SERVICE_URL',
    );

    if (!rpcUrl || !contractAddress || !workflowServiceUrl) {
      throw new Error('Missing required configuration values');
    }

    this.provider = new ethers.providers.JsonRpcProvider(rpcUrl);
    this.contractAddress = contractAddress;
    this.workflowServiceUrl = workflowServiceUrl;

    this.logger.log(
      'Provider, Contract Address, and Workflow Service URL initialized',
    );
  }

  async onModuleInit() {
    this.logger.log('onModuleInit called');
    this.monitorBlocks();
  }

  private monitorBlocks() {
    this.logger.log('monitorBlocks called');
    this.provider.on('block', async (blockNumber) => {
      this.logger.log(`New block: ${blockNumber}`);
      const block = await this.provider.getBlockWithTransactions(blockNumber);

      for (const tx of block.transactions) {
        if (
          tx.to &&
          tx.to.toLowerCase() === this.contractAddress.toLowerCase()
        ) {
          this.logger.log(`Transaction to monitored contract: ${tx.hash}`);
          await this.processTransaction(tx);
        }
      }
    });
  }

  private async processTransaction(tx: ethers.providers.TransactionResponse) {
    try {
      const parsedTransaction = this.contract.interface.parseTransaction({
        data: tx.data,
      });
      this.logger.log(`Function called: ${parsedTransaction.name}`);

      const functionFragment = this.contract.interface.getFunction(
        parsedTransaction.name,
      );

      // Check if the contract is paused using a static call
      let isContractPaused = false;
      try {
        isContractPaused = await this.contract.paused();
      } catch (error) {
        this.logger.warn(
          `Failed to check if contract is paused: ${error.message}`,
        );
        // Assume contract is not paused if we can't check
      }

      if (
        !isContractPaused &&
        functionFragment &&
        functionFragment.stateMutability !== 'view' &&
        functionFragment.stateMutability !== 'pure' &&
        parsedTransaction.name !== 'pauseContract'
      ) {
        this.logger.log(
          'State-changing function detected on non-paused contract, notifying workflow service',
        );
        const exploitData = {
          address: tx.from,
          amount: ethers.utils.formatEther(tx.value),
          transactionHash: tx.hash,
          blockNumber: tx.blockNumber,
          gasUsed: tx.gasLimit.toString(),
          contractAddress: tx.to,
          exploitType: parsedTransaction.name,
          status: 'pending',
        };
        await this.notifyWorkflowService(exploitData);
      } else {
        this.logger.log(
          `Skipping notification: ${
            isContractPaused
              ? 'Contract is paused'
              : `${functionFragment.stateMutability} function or 'pause contract' detected`
          }`,
        );
      }
    } catch (error) {
      this.logger.error(
        `Failed to process transaction: ${tx.hash}. Error: ${error.message}`,
      );
    }
  }

  private async notifyWorkflowService(data: {
    address: string;
    amount: string;
    transactionHash: string;
    blockNumber: number;
    gasUsed: string;
    contractAddress: string;
    exploitType: string;
    status: string;
  }) {
    try {
      const response = await axios.post(this.workflowServiceUrl, data);
      this.logger.log(
        `Notification sent to Workflow Service. Response status: ${response.status}`,
      );
    } catch (error) {
      this.logger.error(`Failed to notify Workflow Service: ${error.message}`);
    }
  }
}
